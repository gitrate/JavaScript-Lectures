/* LECTURE_01 - типы данных */
// **********************************

/* горячие клавиши Notepade++
Alt + 0 - свернуть всё
Alt + Shift + 0 - развернуть всё
Ctrl + Alt + /Shift + F - свернуть/развернуть текущий блок
левая кнопка мыши (ЛКМ) - перетаскивает выделенный код
Ctrl + ЛКМ - копирует выделенный код
Alt + ЛКМ - прямоугольное выделение текста
Ctrl + Shift + Up/Down - перемещать строку вверх/вниз
Ctrl+BackSpace - удалить все слово (влево)
Ctrl+Delete - удалить все слово (вправо)
Ctrl+Shift+BackSpace - удалить с начала строки
Ctrl+Shift+Delete удалить до конца строки
Ctrl+U - конвертация букв в прописные буквы
Ctrl+Shift+U - конвертация букв в ЗАГЛАВНЫЕ БУКВЫ
Ctrl+B - перейти к скобке (только сначала выделите любую скобку)

Ctrl + D - дублировать строку или выделение

(в Notepade++ должен быть включен язык JavaScript)
Ctrl + /Shift/ + K - однострочный комментарий поставить/убрать
Ctrl + /Shift/ + Q - многострочный комментарий поставить/убрать

Автозавершение
	функций - Ctrl + пробел
	параметр функции - Ctrl + Shift + пробел
	слова - Ctrl + Enter
	путь - Ctrl + Alt + пробел

	View > Always on Top - иногда удобно работать с браузером
	F11 - убрать/вернуть меню
	F12 - убрать/вернуть во весь экран
	Ctrl + Num +/Num- - text zoom
	Ctrl + Alt + /Shift + F - свернуть/развернуть текущий блок
 */
/* Способы подключения скриптов:
1. в head
2. в конце файла (чтобы не задерживать загрузку страницы)
3. подключение скрипта
Атрибуты подключения defer и async - 
defer - скрипты срабатывают и выполняются последовательно
async - скрипты срабатывают и выполняются по мере загрузки
оба атрибута не стопорят работу html-кода на странице

верблюжьяНотация
переменные и функции - lowerCamelCase
классы - UpperCamelCase
константы - SCREAMING_SNAKE_CASE - змеиный регистр
желательно каждую логическую операцию заканчивать ";"

комментарий используют для отладки
//однострочный комментарий
/* многострочный комментарий */
/* макросы
сниппеты не пробовали ???
*/
/* отладка при помощи:

всплывающего окна
alert("Hello World"); (недостаток - прерывает выполнение кода html-страницы, не умеет выводить объекты (только примитивы))

вывода в консоль console.log("Hello World"); (открывается по нажатию F12)
набирать и выполнять код можно прямо в консоли

меток, которые выставляются в окне Sources (рядом с консолью (Console)) и останавливают выполнение кода в этом месте

debugger;
*/
/* use strict
директива
"use strict"; (к примеру, запрещает объявлять переменные без var)
прописывают в начале файла/в теле функции
*/
/* символы для именования переменных
azAZ09$_
var - локальное объявление переменной
*/
/* типы данных:
примитивы (5 штук):
number, string, boolean, null, undefined
объекты:
объект, массив, функция
*/
 /* typeof
 оператор typeof передаёт тип переданных данных
 var x = 12;
 console.log(typeof x);
 */
/* объект
var x = {
	key1: "value1";
	key2: "value2";
	"key3": "value3"; (компрессор сжимает ключи, но всё, что в кавычках, считает строками и не трогает. Таким образом, кавычками можно запретить менять имя ключа, если это нарушает работу программы)
}
console.log(typeof x); // "object"
обращение к элементам объекта либо через точку:
x.key1 = "new value";
либо через квадратные скобки:
x["key2"] = "new value 2";
*/
 /* массив
 var x = ["element1", "element2", 25, {}, [], null];
 console.log(typeof x); // "object"
 Array.isArray(x); // true
 обращение к элементам массива только через квадратные скобки с числом (номером элемента):
 console.log(x[3]); // 25
 x[3] = 56;
 console.log(x[3]); // 56
 добавление свойства объекта:
 x.test = 123;
 console.log(x.test); // 123
 длина массива при добавлении свойства не меняется 
  */
/* функция
var x = function () {};
console.log(typeof x); // "function" (исключение, typeof выдаёт не тип "объект", но тип "функция")

плохая практика - добавление функции свойств объекта:
x.key1 = "test";
console.log(x.key1); // "test"
*/
/* ссылочный тип
var x = ["123"];
console.log(x); // ["123"]
var y = x;
console.log(y); // ["123"]
меняем y:
y[0] = 345;
проверяем изменения в y:
console.log(y); // [345]
проверяем изменения в x:
console.log(x); // [345]
Объекты ссылаются на одно и то же место в памяти, соответственно, любой объект - ссылка на место в памяти.
*/ 
 
/* LECTURE_02 - операторы */
// **********************************

/* операнд
 - то, к чему применяется оператор (число, строка, ..?)
 операторы имеют приоритеты выполнения
*/
/* унарные операторы
+ унарный плюс (если поставить перед переменной со строкой, меняет на выводе тип со строки на число, но не меняет саму переменную)
var x = "-5";
console.log(+x); // -5
console.log(x); // "-5"

- унарный минус (если поставить перед переменной со строкой, меняет на выводе тип со строки на число и меняет его знак, но не меняет саму переменную)
var x = "-5";
console.log(-x); // 5
console.log(x); // "-5"

Чтобы изменить саму переменную, присваиваем ей +x:
x = +x;
console.log("typeof x =", typeof x); // number
*/
/* операторы сравнения
за исключением некоторых случаев, стараются привести всё к числу, поскольку числа легко сравнить

операторы сравнения всегда возвращают булево значение
console.log(null == undefined); // true
console.log(null === undefined); // false

*** сравнение строк
сравнение идёт по коду символа посимвольно (первый символ с первым, второй со вторым, сравнение идёт до тех пор, пока не найдётся один символ, который больше/меньше другого):
console.log(x > y); // false (кто позже по алфавиту, тот и больше по коду символа)
console.log(x > Y); // true (код строчных символов больше кода ЗАГЛАВНЫХ, маленькие буквы больше больших)
console.log("tesa" > "tes"); // true, при равных частях, у левой части на один символ больше, значит, левая часть больше
console.log("1" > "2"); // false
console.log("12" > "2"); // false (1 < 2, дальше сравнение останавливается)
console.log(+"12" > +"2"); // true, унарный плюс приводит строку к числу

*** сравнение разных типов
console.log("2" > 1); true
console.log("1.0" == 1); true
console.log(true == 1); true (true приводится к 1, false приводится к 0)
console.log(false == ""); true
console.log(false == 0); true
*** сравнение null и undefined
null и undefined равны только друг другу
console.log(null == undefined); true
console.log(null > 0); false
console.log(null == 0); false
console.log(null >=0); true
console.log(null <=0); true
*/
/* логические операторы
логические операторы && и || не преобразуют возвращаемое значение к булевому виду. Из операторов можно строить цепочки.

&& - логическое и - останавливается на первом (левом или правом) ложном значении и возвращает его. Если в левой части true, то оно в любом случае возвращает правую часть оператора
 

|| - логическое или - останавливается на первом (левом или правом) истинном значении и возвращает его. Если в левой части false, то оно в любом случае возвращает правую часть оператора

! - логическое не - преобразует возвращаемое значение к булевому виду:
console.log(!4); // false
!! - двойное логическое "не" используется для приведения значения к булевому виду:
console.log(!!4); // true

0, "", false, null, undefined, NaN, ![], !{}, !function()== false;
!0, "some text", !false, !null, !undefined, !NaN, [], {}, function() == true;
5, -5, "asd" - дают true
*/
/* бинарные операторы
+
-
*
/
% - деление по модулю
*/
/* запятая, скобки, NaN
запятая имеет самый низкий приоритет (0)
var x = 10, y = 5, z = x + y; // 10 5 15
присвоение идёт слева направо
var z = x + y, x = 10, y = 5; // 10 5 NaN

Когда JS не может выполнить математическую операцию, он возвращает "не число" - "Not a Number" - "NaN"
NaN не равно ничему, даже самому себе.
if(NaN != NaN) {console.log("NaN != NaN");} // "NaN != NaN"
console.log(typeof NaN); // number

скобки имеют самый высокий приоритет (19)
var x = 5,6; // Uncaught SyntaxError: Unexpected number
var x = (5,6); // 6
*/ 
/* экранирование
обратный слэш экранирует символы в строке:
console.log('\" \! \\ \' ');
использование разных кавычек:
console.log('rest "test" qwest'); // rest "test" qwest
*/
/* побитовые операторы
практически не рассматривали
~ - побитовое "не" (тильда)
 */
/* операторы инкремента и декремента
в отличие от унарных, действительно меняют переменную и работают только с переменными (которые содержат числа)
префиксная форма и постфиксная
var x = 4;
console.log(++x); // 5
console.log(x); // 5

var y = 6;
console.log(y++); // 6
console.log(y); // 7
*/
/* условный оператор if, if else
	использует нестрогое сравнение, типы могут приводиться
	оператор не возвращает никакого значения
	if(true) {
		console.log("action");
	}
Форма записи без фигурных скобок - действие записывается только в одну строку:
	if(true)
		console.log("action"); // нечитабельно, не рекомендуется записывать без фигурных скобок
*** if else
	Если if выполняется, else пропускается.
	else  выполняется всегда, если не віполняется if
*** if() {}
	else if() {}
	else if() {}
	else if() {}
	else {}
*/
/* тернарный оператор
использует нестрогое сравнение, типы могут приводиться,
похож на if else, но в отличие от if обязательно возвращает значение
Если условие выполняется - возвращает "then" ("test"),
иначе возвращает "else" ("rest") */
// var x = /* if */ 10 > 5 ? /* then */ "test" : /* else */ "rest";
/* switch case
при сравнении использует строгое сравнение (===)
var x = "text";
switch (x) {
	case "text":
		console.log("Action 1");
		break;
	case "lost":
		console.log("Action 2");
		break;
	case true:
		console.log("Action 3");
	default:
		console.log("default action");
}

Использовать default не обязательно.
case's могут иметь общее действие:

var x = "text";
switch (x) {
	case "text":
		console.log("Action 1");
		break;
	case "lost":
	case true:
		console.log("Action 3");
	default:
		console.log("default action");
}

в case'ах могут стоять условия:
var dataType = null;
switch (true) {
	case typeof dataType == "string":
		console.log("Action 1");
		break;
	case typeof dataType == "number":
		console.log("Action 2");
	default:
		console.log("default action");
}
*/

/* LECTURE_03 - циклы */
// **********************************

/* while
*/
/* do while
*/
/* for
    for(var i = 0; i < 10; i++) {
		console.log(i);
	}
	или
	i = 10;
	for (;i > 5;) {
		i--;
		console.log(i);
	}
*/
/* директивы break и continue
	Для прерывания цикла используют директивы break (останавливает цикл полностью) и continue (переходит на следующий шаг) - это работает для всех циклов.
	var i = 0;
	while (true) {
		console.log(i);
		i++;
		if(i > 10) {
			break;
		}
	}
	
	var i = 0;
	do {
		console.log(i);
		i++;
		if(i > 10) {
			break;
		}
	} while (i < 100);
	
	for(var i = 0; i < 100; i++) {
		console.log(i);
		if(i > 10) {
			break;
		}
	}
	var i = o;
	while(i < 10) {
		i++;
		if (i > 5 && i < 8) {
			continue;
		}
		console.log(i);
	}
	
	do {
		i++;
		if (i > 5 && i < 8) {
			continue;
		}
		console.log(i);
	} while (i < 10);
	
	for(var i = 0; i < 10; i++) {
		if(i > 5 && i < 8) {
			continue;
		}
		console.log(i);
	}
Директивы break и continue нельзя использовать в тернарном операторе, т.к. он обязательно что-то возвращает, а директивы прерывают работу оператора - будет ошибка.
*/
/* Прерывание цикла по ключу.
Из дочерних циклов можно прерывать родительский (сам цикл (не родительский) тоже прервётся).
var i = 0;
outerFor: while (true) {
	console.log("outer i=", i);
	while (true) {
		i++;
		console.log("inner i =", i);
		if(i > 10) {
			break outerFor;
		}
	}
}

var i = 0;
outerFor: while (true) {
	console.log("outer i=", i);
	while (true) {
		i++;
		console.log("inner i =", i);
		if(i > 10) {
			break outerFor;
		}
	}
}

var i = 0;
outerFor: while (true) {
	console.log("outer i=", i);
	while (true) {
		i++;
		console.log("inner i =", i);
		if(i > 10) {
			break outerFor;
		}
	}
}

var i = 0;
outerFor: do {
	console.log("outer i=", i);
	do {
		i++;
		console.log("inner i =", i);
		if(i > 10) {
			break outerFor;
		}
	} while (true);
} while (true);

outerFor: for(var i = 9; ;) {
	console.log("outer i =", i);
	for(;;) {
		i++;
		console.log("inner i =", i);
		if (i > 10) {
			break outerFor;
		}
	}
}

outer: for(var i = 0; i < 100 ;) {
	console.log("outer i =", i);
	for(;;) {
		i++;
		console.log("inner i =", i);
		if (i > 10) {
			continue outer;
		}
	}
}

var i = 0;
outer: while(i < 30) {
	console.log("outer i =", i);
	while (true) {
		console.log("inner i =", i);
		i++;
		if (i > 10) {
			continue outer;
		}
	}
}

var i = 0;
outer: do {
	console.log("outer i =", i);
	do {
		console.log("inner i =", i);
		i++;
		if (i > 10) {
			continue outer;
		}
	} while (true);
} while(i < 30);
*/
/* for in, перебор свойств объекта
Цикл for in работает точно так же, но используется для перебора свойств объекта.

var object = {
	key1: "value 1",
	key2: "value 2",
	key3: "value 3",
	anyKeyName: "any data",
	isObject: {
		test: "test"
	},
	isArray: [1, 2, null]
}
Есть два способа обратиться к свойству объекта.
Через точку:
console.log(object.key1); // в key1 не может быть переменной
Или через квадратные скобки и ключ в виде строки:
console.log(object["key2"]); // в key2 может быть переменная
Именно это свойство (обращение через квадратные скобки) и используется в цикле for in:

for (var key in object) {
	console.log(key);
	console.log(object[key]);
}
Цикл не перебирает дочерние объекты или массивы - только то, что мы непостедственно передали в условии.
*/
/* for in, перебор свойств массива (не рекомендуется)
не рекомендуется перебирать свойства массива циклом for in, потому что, если у массива было какое-то свойство, то оно переберётся тоже:

var array = [1, 2, 4, "string", null];
// свойство:
// array.someKey = "some value"; // dicrease speed of work with array

for(var index in array) {
	console.log(index);
	console.log(array[index]);
}

*/
/* массивы
// arrays definition
var arr = [];
var arr = [1, "string", null];
var arr = new Array(); // []; (метод new конструктора Array)
var arr = new Array(1, "string", null); //[1, "string", null]
var arr = new Array(2); // [undefined, undefined];

console.log(arr.length);
console.log(arr[0]);
console.log(arr);
*/
/* недостаток работы с консолью
var arr = new Array(2); // [undefined, undefined];

console.log(arr.length);
console.log(arr[0]);
console.log(arr);

arr[0] = "test";
console.log(arr[0]);
arr[0] = "rest";
// arr[0] уже присвоено "rest", но консоль показывает console.log(arr[0]) - test, хотя, если раскрыть массив, то внутри будет верное значение. Чтобы не ошибаться, надо выводить в консоли свойства на уровне примитивов (а не объектов) или дебажить с брейкпоинтом.
*/
/* обращение к элементам массива
совершается по индексу:
array[1];
*/
/* array.lenth
есть у каждого массива, оно возвращает длину массива:
array.length;

с помощью array.length можно быстро очистить массив:
var array = [1, 2, "test"];
array.length = 0;
console.log(array); // пустой массив

так же, с помощью array.length можно быстро увеличить массив:
var array = [1, 2, "test"];
array.length = 10;
console.log(array); // массив на 10 элементов [1, 2, "test", undefined * 7]
*/
/* array.push
для добавления элемента в конец массива используется метод push, который возвращает новую длину массива?????????????или индекс??????????

var arr = [1, 2, 3];
console.log(arr.length); // 3
console.log(arr.push(10)); // 4
console.log(arr.length); // 4

arr.push("test") > 4 && console.log("We have a big array!");
// или
var newLength = arr.push("rest");
console.log(newLength);
*/
/* Array.isArray
проверяет, что элемент является именно массивом, возвращает true или false
var arr = [1, 2, 3];
console.log(Array.isArray(arr));
*/

/* LECTURE_04 - функции */
// **********************************

/* Функция
всегда возвращает какое-то значение (либо то, что прописано в return, либо undefined)
Если функция является свойством какого-либо объекта, лна называется метод.
Функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
В то же время, Function Declaration при use strict видны только внутри блока, в котором объявлены. Поэтому, если мы не хотим получить ошибку, то Function Declaration нужно осуществлять вне блоков кода (if, for, etc...), "снаружи".

А Function Expression создаются в процессе выполнении выражения, в котором созданы, поэтому могут быть заданы в любом месте кода.

Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.
Действительно, зачем нам записывать функцию в переменную, если мы не собираемся вызывать её ещё раз? Можно просто объявить непосредственно там, где функция нужна.

Существует ещё один способ создания функции, который используется очень редко, но упомянем и его для полноты картины - при помощи new Function.

Он позволяет создавать функцию полностью «на лету» из строки, вот так:

 var sum = new Function('a,b', ' return a+b; ');
 var result = sum(1, 2);
 console.log(result);
 Таким образом можно конструировать функцию, код которой неизвестен на момент написания программы, но строка с ним генерируется или подгружается динамически во время её выполнения.

// It's function // functional declaration
function fn () {}

var object = {}; 

// It's method
object.method = function () {};

// It's functional expression
var functionX = function () {};

// Именованное функциональное выражение
var functionX = function fnName() {};
// рекурсия
var functionX = function fnName() {
	if(true) {
		fnName();
	}
};
// объявление функции через конструктор new Function:
var newFnName = new Function("x", "return x");
console.log(newFnName(256));
*/
/* анонимная самовызывающаяся функция (будет сразу вызвана)
Для того, чтобы вызвать функцию, мы оборачиваем её в скобки. Всё, что в скобках - выражение, а выражение обязательно выполняется. Кстати, если в качестве возвращаемого значения в тернарный оператор записать функцию, то она сработает без оборачивающих скобок, потому что тернарный оператор и так является выражением. Так же без скобок сработает функция и в операции сравнения, главное, не забывать указывать скобки после функции, иначе такой вызов вернёт тело функции.
(function() {
	console.log("test 1");
}) ();

(function() {
	console.log("test 1");
}());
*/
/* именованная самовызывающаяся функция

(function privatName(x) { //(x)==(var x = x)
	console.log(x);
	if (x < 1) {
		privatName(x + 1); // рекурсия
	}
}) (0);

(functionprivatName() {
	console.log(x);
	if (x < 1) {
		privatName(x + 1); // рекурсия
}(0));

var test = (function privatName(x) {
	if (x < 10) {
		return privatName(x + 1);
	}
	return x;
}) (0);
console.log(test);
*/
/* функции в объектах
в следующем примере - это лишь элементы массива:

var arrayWithFunctions = [
	function () {return 0;},
	function () {return 1;},
	function () {return 2;}
];
// а вот ниже - это уже метод:
arrayWithFunctions.methodOfArray = function () {return "I'm a method"};

console.log(arrayWithFunctions[1]());
console.log(arrayWithFunctions.methodOfArray());
// *******************************
function fnName() {
	return "I'm a function";
}
fnName.methodOfFunction = function() {
	return "I'm a method";
}

console.log(fnName); // без скобок мы увидим тело функции
console.log(fnName()); // I'm a function
console.log(fnName.methodOfFunction()); // I'm a method
console.log(fnName["methodOfFunction"]()); // I'm a method
// ******************************
function fnName() {
	return "I'm a function";
}
var newFunction = fnName;
// newFunction - это новая ссылка на старую функцию, которая может работать точно так же в том же коде
console.log(newFunction()); // I'm a function
console.log(newFunction.methodOfFunction()); // I'm a method
// и даже если написать в эту переменную другое значение, 
newFunction = null;
// то ИСХОДНАЯ функция от этого никак не изменится и не пострадает:
console.log(fnName()); // I'm a function
console.log(fnName.methodOfFunction()); // I'm a method
*/
/* локальная переменная arguments
в каждой функции есть псевдо-массив arguments - 
это массив тех значений (аргументов), которые передали в функцию.
Функция может и вовсе не ожидать ни одного аргумента, но при этом получить их и работать с ними:
function test () {
	console.log(arguments);
	var x = Array.apply(null, arguments); // методы apply и call первым параметром передают контекст, а нам контекст не нужен, поэтому мы и указали null
	console.log("argumentsToX", x); // получили полноценный массив x с копией элементов из псевдо-массива arguments
}
console.log(test(1, 2, [], {}, null,  undefined));
*/
/* область видимости
с областью видимости в JS всё логично.
по окончании работы функции, все переменные, которые были заданы внутри функции, удаляются (за одним исключением - тема отдельной лекции), этот механизм называется "garbage collection" :)
throw - это оператор, который "бросает" в консоль ошибку и останавливает выполнение кода

function getAllNulls (array) {
	if (!Array.isArray (array)) {
		throw ("Attribute array is not array");
		console.log("eryjy"); // строка не выводится, работа функции остановлена в строке выше
	}
	var nullsArray = [];
	for (var i = 0; i < array.length; i++) {
		if (array[i] === null) {
			nullsArray.push (array[i]);
		}
	}
	return nullsArray;
}

console.log(getAllNulls([1, 23, "asd", null, undefined, [1, 2, null], {"null": null}, null]));
console.log(getAllNulls("fuhuygty"));
*/

/* LECTURE_05 */
/* LECTURE_06 */

/* LECTURE_07 - объекты, массивы */
// **********************************

/* создание объекта

// через фигурные скобки
var obj = {};

// через конструктор класса
var obj = new Object();

// сразу задавать свойства (два способа ниже идентичные и не имеет значения, сразу мы добавляем значения, или постепенно)

// 1
var obj = {
	key1: "value1",
	key: null,
	"user": {
		"firstname": "Vasya",
		lastname: "Sidorov"
	}
};

// 2
var object = {};
object.key1 = "value1";
object.key2 = null;
object["user"] = {
	"firstname": "Vasya",
	lastname: "Sidorov"
};

// свойством объекта может быть любая сущность, в т.ч. и другой объект, функция (которая в таком случае называется методом объекта), массив, массив с другими объектами, JS не накладывает ограничений
*/
/* удаление объекта

var obj = {
	key1: "value1",
	key: null,
	"user": {
		"firstname": "Vasya",
		lastname: "Sidorov"
	}
};

console.log(object.key1);
 delete object.key1;
console.log(object.key1);
*/
/* два способа проверить, есть ли в объекте СВОЙСТВО или нет
var obj = {
	key1: "value1",
	key: null,
	"user": {
		"firstname": "Vasya",
		lastname: "Sidorov"
	}
};

 // delete object.key1;
 object.key1 = undefined;
 // *************************************
  object.key1 = undefined;
// способ 1 проверяем на undefined
if (object.key1 !== undefined) {
	console.log("No result"); // "нет вывода"
// при простом сравнении, наличие такого свойства будет неотличимо от его отсутствия.
}
// способ 2 используем оператор in
if ("key1" in object) {
	console.log("Has result"); // "Has result"
}
// во втором случае видим, что свойство находится, несмотря на удаленное свойство. Почему? Потому что даже если значение свойства равно undefined, оператор in даёт true. Оператор in гарантирует правильный результат
*/
/* перебор свойств объекта (2 основных способа)

// цикл for in выдаёт на каждой итерации ИМЯ свойства объекта
for (var key in object) {
	console.log(object[key]); 
}
// свойства выводятся в том порядке, в котором они были записаны в объект (null, Object, undefined), новые свойства добавляются в конец. Но есть исключение: положительные числовые свойства (строки) выводятся первыми и в порядке возрастания

var object = {
	"10": "value3",
	"1": "value1",
	"25": "value2",
	"test1": "value4",
	"asd": "value5",
	"15": "value6"
};

for (var key in object) {
	console.log(object[key]); 
} // value1,value3,value6,value2,value4,value5
// или выведем сами ключи для наглядности:
for (var key in object) {
	console.log(key); 
} // 1,10,15,25,test1,asd
*/
/* перебор свойств объекта методом Object.keys() с получением массива ключей. Для этого у базового класса Object есть метод keys, он принимает в себя объект и возвращает массив его ключей

var obj = {
	"10": "value3",
	"1": "value1",
	"25": "value2",
	"test1": "value4",
	"asd": "value5",
	"15": "value6",
	"+11": "value7"
};

var keysArr = Object.keys(obj);

console.log(keysArr);
// Object.keys() выводит только собственные свойства массива
*/
/* выводим свойства объекта [ пары ключ/значение ]
var obj = {
	"10": "value3",
	"1": "value1",
	"25": "value2",
	"test1": "value4",
	"asd": "value5",
	"15": "value6",
	"+11": "value7"
};

var keysArr = Object.keys(obj);

for (var i = 0; i < keysArr.length; i++) {
	console.log( keysArr[i], obj[keysArr[i]] ); // keysArr[i] - ключ, obj[keysArr[i]] - значение
}
// цикл for() выводит не только собственные свойства массива, но и наследуемые (свойства прототипа)
*/
/* примитивы копируются по значению, а объекты копируются по ссылке

*/
/* атрибуты свойств

Основной метод для управления свойствами – Object.defineProperty.

Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.

Синтаксис:

Object.defineProperty(obj, "propName", {
	enumerable: true,
	writable: false
})
Аргументы:

obj
Объект, в котором объявляется свойство.
propName
Имя свойства, которое нужно объявить или модифицировать.
descriptor
Дескриптор – объект, который описывает поведение свойства.
В нём могут быть следующие поля:

value – значение свойства, по умолчанию undefined
writable – значение свойства можно менять, если true. По умолчанию false.
configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.
enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
get – функция, которая возвращает значение свойства. По умолчанию undefined.
set – функция, которая записывает значение свойства. По умолчанию undefined.
Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.
*/
/* зададим свойство
два таких вызова работают одинаково:
var user = {};

// 1. простое присваивание
user.name = "Вася";

// 2. указание значения через дескриптор
Object.defineProperty(user, "name", { value: "Вася", configurable: true, writable: true, enumerable: true });
*/
/* свойство-константа
// Для того, чтобы сделать свойство неизменяемым, изменим его флаги writable и configurable:

"use strict";

var user = {};

Object.defineProperty(user, "name", {
  value: "Вася",
  writable: false, // запретить присвоение "user.name="
  configurable: false // запретить удаление "delete user.name"
});

// Теперь попытаемся изменить это свойство.

// в strict mode присвоение "user.name=" вызовет ошибку
user.name = "Петя";

// Заметим, что без use strict операция записи «промолчит» но не сработает. Лишь если установлен режим use strict, то дополнительно сгенерируется ошибка.

*/
/* атрибут: принимаемые_значения - коментарий
 value: number/string/object etc. - значение свойства
 configurable: true/false - добавление и удаление свойств
 writable: true/false - редактирование свойств
 enumerable: true/false - доступность свойства при переборе в for...in
 */
/* функции-перехватчики get: и set:
 GET (перед выдачей, отдаёт значение в функцию)
 get: function() {} - cвойство-функция, связывает свойство объекта с функцией, которая будет вызываться  при обращении к этому свойству.
 Если желательно разрешить доступ к свойству, которое возвращает динамически вычисляемое значение, или вы можете захотеть отражать состояние внутренней переменной без необходимости использования явных вызовов методов, используйте геттер.
	
	Синтаксис:
		геттер может иметь идентификатор, который является либо числом, либо строкой;
		он должен иметь только нулевые параметры;
		он не должен появляться в объектном литерале вместе с другим get или через ввод данных для того же свойства:
		ЗАПРЕЩЕНЫ
		{ get x() { }, get x() { } }
		{ x: ..., get x() { } }
	
	Геттер можно удалить при помощи оператора delete.
	
	примеры:
// ***************************************	
var log = ['test', 'fest'];

var obj = {
  get latest () {
    if (log.length == 0) return undefined;
    return log[log.length - 1];
  }
}
console.log (obj.latest); // вернет "fest"
// ***************************************
delete obj.latest;
// ***************************************
var obj = { a:0 }

Object.defineProperty(obj, "b", { get: function () { return this.a + 1; } });

console.log(obj.b) // Runs the getter, which yields a + 1 (which is 1)
// ***************************************
SET (перехватывает присылаемое значение в функцию перед его установкой)
set: {set prop(val) { . . . }}
{set [expression](val) { . . . }}
cвязывает свойство объекта c функцией, которая будет вызвана при попытке установить это свойство.
Сеттер может быть использован для выполнения функции всякий раз, когда предпринимается попытка изменить заданное свойство. Сеттеры чаще всего используются в сочетании с геттерами для создания типа псевдо-свойства. Нельзя устанавливать сеттер на свойство, которое имеет фактическое значение.
	Синтаксис:
		Он может иметь идентификатор, который является либо числом, либо строкой;
		Он должен иметь ровно один параметр;
		Он не должен появляться в виде литерала объекта с другим набором или с вводом данных для того же свойства:
		ЗАПРЕЩЕНЫ
		{ set x(v) { }, set x(v) { } }
		{ x: ..., set x(v) { } }
		
	Сеттер можно удалить при помощи оператора delete.

	примеры:
// ***************************************
var language = {
  set current (name) {
    this.log.push(name);
  },
  log: []
}

language.current = 'EN';
console.log(language.log); // ['EN']

language.current = 'UA';
console.log(language.log); // ['EN', 'UA']
// ***************************************
delete obj.current;
// ***************************************
var obj = { key1:0 };

Object.defineProperty(obj, "key2", { set: function (x) { this.key1 = x / 2; } });

obj.key2 = 10; // запускает сеттер, который присваивает 10 / 2 (5) свойству 'key1'
console.log(obj.key1) // 5
// ***************************************
var expr = "my";

var obj = {
  precious: "ring",
  set [expr](lost) { this.precious = lost; }
};

console.log(obj.precious); // "ring"
obj.my = "precious";      // run the setter
console.log(obj.precious); // "precious"
// ***************************************
*/
/* 1 - Object.defineProperty



"use strict"
var object = {
	"key1": 10,
	"key2": 15
}

Object.defineProperty (object, "key1", {
	writable: false
});
// ********************************
Object.defineProperty (object, "key1", {
	writable: true
});
// ********************************
object.key1 = 25;
console.log(object.key1);

Object.defineProperty (object, "key1", {
	configurable: false,
	writable: false,
	enumerable: false
});

console.log(Object.keys(object));

Object.defineProperty (object, "key1", {
	configurable: true
}); // ERROR

// ********************************
var object = {
	"key1": 10,
	"key2": 15
}

Object.defineProperty (object, "key1", {
	writable: false
});

console.log(object.key1);

Object.defineProperty (object, "key1", {
	value: 5
});

console.log(object.key1);
// ********************************
*/
/* 2 - Object.defineProperties

var object = {
	firstName: "Test",
	lastName: "Test2"
}

Object.defineProperties(object, {
	"fullName": {
		get: function () {
			return this.firstName+" "+this.lastName;
		},
		set: function (newValue) {
			this.firstName = newValue.split(" ")[0];
			this.lastName = newValue.split(" ")[1];
		},
	},
	"age": {
		value: 18,
		enumerable: true,
		writable: false
	}
})

console.log(object.fullName);
console.log(object.age);
*/
/* методы массива push, pop, unshift, shift
все эти методы меняют исходный массив
*/
/* метод push
добавляет элемент в конец массива, возвращает новую длину массива

// var array = [0,1];
// console.log("Push 10:", array.push(10)); // 3
// console.log(array); // [0,1,10]

*/

/* метод split (разбиение строки в массив)


Ситуация из реальной жизни. Мы пишем сервис отсылки сообщений и посетитель вводит имена тех, кому его отправить: Маша, Петя, Марина, Василий.... Но нам-то гораздо удобнее работать с массивом имен, чем с одной строкой.

К счастью, есть метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю s. В примере ниже таким разделителем является строка из запятой и пробела.

 var names = 'Маша, Петя, Марина, Василий';

var arr = names.split(', ');

for (var i = 0; i < arr.length; i++) {
  alert( 'Вам сообщение ' + arr[i] );
}
Второй аргумент split
У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен:

                              alert( "a,b,c,d".split(',', 2) ); // a,b
Разбивка по буквам
Вызов split с пустой строкой разобьёт по буквам:

 var str = "тест";

alert( str.split('') ); // т,е,с,т
*/
/* метод join (массив в строку)

Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.

Например:

 var arr = ['Маша', 'Петя', 'Марина', 'Василий'];

var str = arr.join(';');

alert( str ); // Маша;Петя;Марина;Василий
new Array + join = Повторение строки
Код для повторения строки 3 раза:

 alert( new Array(4).join("ля") ); // ляляля
Как видно, new Array(4) делает массив без элементов длины 4, который join объединяет в строку, вставляя между его элементами строку "ля".

В результате, так как элементы пусты, получается повторение строки. Такой вот небольшой трюк.
*/
/* метод delete - удаление из массива

Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete:

 var arr = ["Я", "иду", "домой"];

delete arr[1]; // значение с индексом 1 удалено

// теперь arr = ["Я", undefined, "домой"];
alert( arr[1] ); // undefined
Да, элемент удален из массива, но не так, как нам этого хочется. Образовалась «дырка».

Это потому, что оператор delete удаляет пару «ключ-значение». Это – все, что он делает. Обычно же при удалении из массива мы хотим, чтобы оставшиеся элементы сдвинулись и заполнили образовавшийся промежуток.

Поэтому для удаления используются специальные методы: из начала – shift, с конца – pop, а из середины – splice, с которым мы сейчас познакомимся.
*/
/* метод shift - удаление из начала массива
удаляет элемент с начала массива, возвращает удалённый элемент
// var array = [256,0,1];
// console.log("Shift", array.shift(256)); // 256
// console.log(array); // [0,1]
*/
/* метод unshift - добавление в начало массива
добавляет элемент в начало массива, возвращает новую длину массива
// var array = [0,1];
// console.log("Unshift 256", array.unshift(256)); // 3
// console.log(array); // [256,0,1]
*/
/* метод pop - удаляет элемент из конца массива
удаляет элемент из конца массива, возвращает его
// var array = [0,1,10];
// console.log("Pop: ", array.pop()); // 10
// console.log(array); // [0,1]  
*/
/* метод splice (сращивание) - удаление, вставка, замена
Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.

Его синтаксис:

arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
Этот метод проще всего понять, рассмотрев примеры.

Начнём с удаления:

 


var arr = ["Я", "изучаю", "JavaScript"];

arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент

alert( arr ); //  осталось ["Я", "JavaScript"]
В следующем примере мы удалим 3 элемента и вставим другие на их место:

 




                                                                          var arr = ["Я", "сейчас", "изучаю", "JavaScript"];

// удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем")

alert( arr ) // теперь ["Мы", "изучаем", "JavaScript"]
Здесь видно, что splice возвращает массив из удаленных элементов:

                          var arr = ["Я", "сейчас", "изучаю", "JavaScript"];

// удалить 2 первых элемента
var removed = arr.splice(0, 2);

alert( removed ); // "Я", "сейчас" <-- array of removed elements
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:

 var arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2
// удалить 0
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:

 var arr = [1, 2, 5]

// начиная с позиции индексом -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // результат: 1,2,3,4,5
*/
/* метод slice (выделение части массива)

Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.

Например:

 var arr = ["Почему", "надо", "учить", "JavaScript"];

var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)

alert( arr2 ); // надо, учить
Аргументы ведут себя так же, как и в строковом slice:

Если не указать end – копирование будет до конца массива:

 var arr = ["Почему", "надо", "учить", "JavaScript"];

alert( arr.slice(1) ); // взять все элементы, начиная с номера 1
Можно использовать отрицательные индексы, они отсчитываются с конца:

var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше
Если вообще не указать аргументов – скопируется весь массив:

var fullCopy = arr.slice();
Совсем как в строках
Синтаксис метода slice одинаков для строк и для массивов. Тем проще его запомнить.
*/
/* метод sort - сортировка на месте
Сортировка, метод sort(fn)

Метод sort() сортирует массив на месте. Например:

 



                          var arr = [ 1, 2, 15 ];

arr.sort();

alert( arr );  // 1, 15, 2
Не заметили ничего странного в этом примере?

Порядок стал 1, 15, 2, это точно не сортировка чисел. Почему?

Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке.

Поэтому и порядок у них строковый, ведь "2" > "15".

Свой порядок сортировки

Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.

Внутренний алгоритм функции сортировки умеет сортировать любые массивы – апельсинов, яблок, пользователей, и тех и других и третьих – чего угодно. Но для этого ему нужно знать, как их сравнивать. Эту роль и выполняет fn.

Если эту функцию не указать, то элементы сортируются как строки.

Например, укажем эту функцию явно, отсортируем элементы массива как числа:

 
















                        function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a < b) return -1;
}

var arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
Обратите внимание, мы передаём в sort() именно саму функцию compareNumeric, без вызова через скобки. Был бы ошибкой следующий код:

                          arr.sort( compareNumeric() );  // не сработает
Как видно из примера выше, функция, передаваемая sort, должна иметь два аргумента.

Алгоритм сортировки, встроенный в JavaScript, будет передавать ей для сравнения элементы массива. Она должна возвращать:

Положительное значение, если a > b,
Отрицательное значение, если a < b,
Если равны – можно 0, но вообще – не важно, что возвращать, их взаимный порядок не имеет значения.
Алгоритм сортировки
В методе sort, внутри самого интерпретатора JavaScript, реализован универсальный алгоритм сортировки. Как правило, это ««быстрая сортировка»», дополнительно оптимизированная для небольших массивов.

Он решает, какие пары элементов и когда сравнивать, чтобы отсортировать побыстрее. Мы даём ему функцию – способ сравнения, дальше он вызывает её сам.

Кстати, те значения, с которыми sort вызывает функцию сравнения, можно увидеть, если вставить в неё alert:

 [1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
});
Сравнение compareNumeric в одну строку
Функцию compareNumeric для сравнения элементов-чисел можно упростить до одной строчки.

function compareNumeric(a, b) {
  return a - b;
}
Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, отрицательное, если наоборот, и 0, если числа равны.
*/
/* метод reverse - меняет порядок элементов в массиве

Метод arr.reverse() меняет порядок элементов в массиве на обратный.

 var arr = [1, 2, 3];
arr.reverse();

alert( arr ); // 3,2,1
*/
/* метод concat - в новый массив = старый массив + аргументы

Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.

Например:

 

var arr = [1, 2];
var newArr = arr.concat(3, 4);

alert( newArr ); // 1,2,3,4
У concat есть одна забавная особенность.

Если аргумент concat – массив, то concat добавляет элементы из него.

Например:

 


var arr = [1, 2];

var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)

alert( newArr ); // 1,2,3,4,5
*/
/* метод indexOf/lastIndexOf - поиск перебором. indexOf возвращает номер элемента searchElement в массиве; lastIndexOf ищет справа-налево: с конца массива или с номера fromIndex, если он указан

Эти методы не поддерживаются в IE8-. Для их поддержки подключите библиотеку ES5-shim.

Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.

Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.

Для поиска используется строгое сравнение ===.

Например:

 var arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
Как вы могли заметить, по синтаксису он полностью аналогичен методу indexOf для строк.

Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан.

Методы indexOf/lastIndexOf осуществляют поиск перебором
Если нужно проверить, существует ли значение в массиве – его нужно перебрать. Только так. Внутренняя реализация indexOf/lastIndexOf осуществляет полный перебор, аналогичный циклу for по массиву. Чем длиннее массив, тем дольше он будет работать.

Коллекция уникальных элементов
Рассмотрим задачу – есть коллекция строк, и нужно быстро проверять: есть ли в ней какой-то элемент. Массив для этого не подходит из-за медленного indexOf. Но подходит объект! Доступ к свойству объекта осуществляется очень быстро, так что можно сделать все элементы ключами объекта и проверять, есть ли уже такой ключ.

Например, организуем такую проверку для коллекции строк "div", "a" и "form":

var store = {}; // объект для коллекции

var items = ["div", "a", "form"];

for (var i = 0; i < items.length; i++) {
  var key = items[i]; // для каждого элемента создаём свойство
  store[key] = true; // значение здесь не важно
}
Теперь для проверки, есть ли ключ key, достаточно выполнить if (store[key]). Если есть – можно использовать значение, если нет – добавить.

Такое решение работает только со строками, но применимо к любым элементам, для которых можно вычислить строковый «уникальный ключ».
*/
/* метод forEach
Современный стандарт JavaScript предоставляет много методов для «умного» перебора массивов, которые есть в современных браузерах…

…Ну а для их поддержки в IE8- просто подключите библиотеку ES5-shim.

forEach

Метод «arr.forEach(callback[, thisArg])» используется для перебора массива.

Он для каждого элемента массива вызывает функцию callback.

Этой функции он передаёт три параметра callback(item, i, arr):

item – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.
Например:

 var arr = ["Яблоко", "Апельсин", "Груша"];

arr.forEach(function(item, i, arr) {
  alert( i + ": " + item + " (массив:" + arr + ")" );
});
Второй, необязательный аргумент forEach позволяет указать контекст this для callback. Мы обсудим его в деталях чуть позже, сейчас он нам не важен.

Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.
*/
/* метод filter
Метод «arr.filter(callback[, thisArg])» используется для фильтрации массива через функцию.

Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.

Например:

var arr = [1, -1, 2, -2, 3];

var positiveArr = arr.filter(function(number) {
  return number > 0;
});

alert( positiveArr ); // 1,2,3
*/
/* метод map

Метод «arr.map(callback[, thisArg])» используется для трансформации массива.

Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.

Например:

 




var names = ['HTML', 'CSS', 'JavaScript'];

var nameLengths = names.map(function(name) {
  return name.length;
});

// получили массив с длинами
alert( nameLengths ); // 4,3,10
*/
/* метод every/some

Эти методы используются для проверки массива.

Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.
Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr. 

var arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number > 0;
}

alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) ); // true, есть хоть одно положительное
*/
/* метод reduce/reduceRight

Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.

Это один из самых сложных методов для работы с массивами. Но его стоит освоить, потому что временами с его помощью можно в несколько строк решить задачу, которая иначе потребовала бы в разы больше места и времени.

Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.

Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.

Аргументы функции callback(previousValue, currentItem, index, arr):

previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
index – номер текущего элемента.
arr – обрабатываемый массив.
Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

Проще всего понять работу метода reduce на примере.

Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.

Вот решение в одну строку:

 var arr = [1, 2, 3, 4, 5]

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current;
}, 0);

alert( result ); // 15
Разберём, что в нём происходит.

При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).

Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее (см. рисунок).

Поток вычислений получается такой:
**************************************
				sum	current	результат*
первый вызов	0	1		1        *
второй вызов	1	2		3        *
третий вызов	3	3		6        *
четвёртый вызов	6	4		10       *
пятый вызов		10	5		15       *
**************************************
Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.

Кстати, полный набор аргументов функции для reduce включает в себя function(sum, current, i, array), то есть номер текущего вызова i и весь массив arr, но здесь в них нет нужды.

Посмотрим, что будет, если не указать initialValue в вызове arr.reduce:

 var arr = [1, 2, 3, 4, 5]

// убрали 0 в конце
var result = arr.reduce(function(sum, current) {
  return sum + current
});

alert( result ); // 15
Результат – точно такой же! Это потому, что при отсутствии initialValue в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же, за вычетом первой строки.

Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.
*/

/* LECTURE_08 - практика */
// **********************************

/* function getRandomInt
// функция возвращает случайное целое число в диапазоне от min до max включительно;
function getRandomInt (min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}
*/
// LECTURE_08 - list_3_exercise_1
/* function addOpacity(hexColor, opacity) {
	if (hexColor.length > 4) {
		var red = parseInt(hexColor[1] + hexColor[2], 16);
		var green = parseInt(hexColor[3] + hexColor[4], 16);
		var blue = parseInt(hexColor[5] + hexColor[6], 16);	// hexColor[6] === undefined;
	} else {
		var red = parseInt(hexColor[1] + hexColor[1], 16);
		var green = parseInt(hexColor[2] + hexColor[2], 16);
		var blue = parseInt(hexColor[3] + hexColor[3], 16);			
	}
	// console.log(hexColor[6]); // undefined
	return "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
}

console.log(addOpacity("#fa0000", .3));
console.log(addOpacity("#cccccc", .7));
console.log(addOpacity("#ccc", .7));
*/
// LECTURE_08 - list_3_exercise_2
/* function blockGrower (width, height) { 		// width = "10px", height = "15.455555%";
	var widthNumber = parseFloat (width); 		// widthNumber = 10;
	var widthUnit = width.slice(widthNumber.toString().length); 		// widthNumber.toString().length = 2; width[2] = "p"; widthUnit от 2-го элемента строки "10px" до конца (для slice не задан второй элемент - значит, до конца) = "px";
	var heightNumber = parseFloat (height); 		// heightNumber = 15.455555; 
	var heightUnit = height.slice(heightNumber.toString().length); 		//heightNumber.toString().length = 9 (символов); heightUnit = "%";
	return {																// it's an object;
		width: Math.round(widthNumber * 1.5 * 10000) / 10000 + widthUnit, 		// "15px"
		height: Math.round(heightNumber * 1.5 * 10000) / 10000 + heightUnit		 // 15.455555 * 1.5 * 10000 = 231833.325; Math.round(231833.325) = (231833); 231833 / 10000 = 23.1833; height: 23.1833 + "%" ("23.1833%");
	}
}

console.log(blockGrower("10px", "15.455555%"));
*/
// LECTURE_08 - list_3_exercise_3
/* function getTwoDigits (min, max) {
	var randomNumbers = [];
	for (var i = 0; i < 5; i++) {
		randomNumbers.push(getRandomInt(min, max));
	}
	console.log(randomNumbers);
	console.log("starting sort");
	randomNumbers.sort(function (a, b) { // загадочный способ задать свой метод сортировки для sort, при вычислении разности пары элементов массива, получаем либо положительное, либо отрицательное число, знак числа каким-то образом влияет на работу sort - разобраться с принципом задания своего метода сортировки для sort
		console.log(a - b);
		console.log(randomNumbers);
		return a - b;
		} )
	
	return {
		min: randomNumbers[0],
		max: randomNumbers[randomNumbers.length - 1]
	}
}

console.log(getTwoDigits (0, 99));
*/
// LECTURE_08 - list_3_exercise_4
/* function checkNumberType (number) {
	return number % 1 ? "float" : "integer";
}
console.log(checkNumberType(0.5));
console.log(checkNumberType(5));
*/
// LECTURE_08 - list_4_exercise_1
/* function getRandomPart (string) {
	return string.substring (
	getRandomInt(0, string.length - 1),
	getRandomInt(0, string.length - 1)
	);
}

console.log(getRandomPart("tasdlk;j;lgfdgjlxcv"));
*/
// LECTURE_08 - list_4_exercise_2
/* function getTwoSymbols (string) {
	var sym1 = string.substr (getRandomInt (0, string.length - 1), 1);
	var sym2 = string.substr (getRandomInt (0, string.length - 1), 1);
	return sym1.toLowerCase() === sym2.toLowerCase() ? sym1 : sym1 + sym2;
}

console.log(getTwoSymbols("tasdlk;j;lgfdgjlxcv"));
*/
// LECTURE_08 - list_4_exercise_3
/* var 1
function wordRemover (word, string) {
	var nextWordIndex = null;
	while(~(nextWordIndex = string.indexOf(word))) {
		var start = string.slice (0, nextWordIndex);
		var end = string.slice (nextWordIndex + word.length);
		string = start + end;
	}
	return string;
}

// var 2
function wordRemoverWithArray (word, string) {
	var arrayOfWords = string.split(" ");
	var nextWordIndex = null;
	while (~(nextWordIndex = arrayOfWords.indexOf(word))) {
		arrayOfWords.splice (nextWordIndex, 1);
	}
	return arrayOfWords.join(" ");
}

// var 3
function wordRemoverWithFilter (word, string) {
	return string.split(" ").filter(function (elem) { return elem !== word}).join(" ");
}

console.log(wordRemover("log", "test log restlog split string olololog"));
console.log(wordRemoverWithArray("log", "test log restlog split string olololog"));
console.log(wordRemoverWithFilter("log", "test log restlog split string olololog"));
*/

/* LECTURE_09 - практика*/
// **********************************************************************************************

// LECTURE_09 - list_5_exersize_1
/* function findBiggestApple (tree, biggestApple) {
	for (var i = 0; i < tree.length; i++) {
		if (Array.isArray(tree[i])) {
			biggestApple = findBiggestApple (tree[i], biggestApple);
		} else {
			biggestApple = biggestApple === undefined ? tree[i] : biggestApple < tree[i] ? tree[i] : biggestApple;
		}
	}
	return biggestApple;
}

console.log(findBiggestApple([-1, -2, [-5, -7, [-11, -2]], [-9,  -8], -7]));
*/
// LECTURE_09 - list_5_exersize_2
/* проверить синтаксис, не работает
function getObjectsValues (tree, result) {
	result = result || [];
	for (var key in tree) {
		if (typeof tree[key] === "object" &&
			tree[key] !== null &&
			!Array.isArray(tree[key])
		) {
			getObjectsValues(tree[key], result);
		} else {
		result.push(tree[key]);
		}
	}
	return result;
}

var obj = {
	key: null,
	key2: {
		key3: "value3",
		key4: {
			key5: "value5",
			key6: "value6"
		}
	}
}
*/
// LECTURE_09 - list_5_exersize_3
/* function getRequiredSymbols (string, type) {
	var arrOfSymbols = string.split (""),
		result = [];
	for (var i = 0; i < arrOfSymbols.length; i++) {
		if (type == "number" &&
			typeof +arrOfSymbols[i] === type &&
			!isNaN(+arrOfSymbols[i]) &&
			arrOfSymbols[i] !== ""
		) {
			result.push(arrOfSymbols[i]);
		} else if (type === "string" && isNaN (+arrOfSymbols[i])) {
			result.push (arrOfSymbols[i]);
		}
	}
	return result.join("");
}

console.log(getRequiredSymbols ('13hfgd5 7&', 'number'));
console.log(getRequiredSymbols ('13hfgd57?68nlc!0>>', "string"));
*/
// LECTURE_09 - list_6_exersize_1
// function getSortedString (string)
/* function getRequiredSymbols (string, type) {
	var arrOfSymbols = string.split (""),
		result = [];
	for (var i = 0; i < arrOfSymbols.length; i++) {
		if (type == "number" &&
			typeof +arrOfSymbols[i] === type &&
			!isNaN(+arrOfSymbols[i]) &&
			arrOfSymbols[i] !== ""
		) {
			result.push(arrOfSymbols[i]);
		} else if (type === "string" && isNaN (+arrOfSymbols[i])) {
			result.push (arrOfSymbols[i]);
		}
	}
	return result.join("");
}

function getSortedString (string) {
	var splitedString = string.split(""),
	numbers = getRequiredSymbols (string, "numbers");
	symbols = getRequiredSymbols (string, "string");
	
	return numbers.split("").sort().join("") + symbols.split("").sort().join("");
}

console.log(getSortedString("dc135ba7e68fg0"));
*/
// LECTURE_09 - list_6_exersize_1 (повтор предыдущей функции???)
/* function getSortedString (string) {
	var splitedString = string.split (""),
	numbers = [],
	symbols = [];
	for (var i = 0; i < splitedString.length; i++) {
		!isNaN(+splitedString[i]) ? numbers.push(splitedString[i]) : symbols.push(splitedString[i]);
	}
	return numbers.sort().join("") + symbols.sort().join("");
}

console.log(getSortedString("dc135ba7e68fg0"));
*/
// LECTURE_09 - list_6_exersize_2
/* function getInvertedNumbers (arrayOfNumbers) {
	return arrayOfNumbers.map(function (elem) {return -elem });
	var result = [];
	
	for (var i = 0; i < arrayOfNumbers.length; i++) {
		result.push (-arrayOfNumbers[i]);
	}
	return result;
}
console.log(getInvertedNumbers([1, 2, -3, 0, -5, -8, 6]));
*/
// LECTURE_09 - list_6_exersize_3
/* function getReversedString (string) {
	return string.split("").reverse().join("");
}
console.log (getReversedString ("glavryba"));
*/
// LECTURE_09 - list_7_exersize_1 (проверить работу)
/* function namesConcatenator (arrayOfObjects) {
	return arrayOfObjects.map (function (elem) {
		return {
			fullName: elem.firstName + " " + elem.lastName,
			age: elem.age,
			gender: elem.gender
		}
	});
	var result = [];
	
	for (var i = 0; i < arrayOfObjects.length; i++) {
		result.push({});
		result[i].fullName = arrayOfObjects[i].firstName + " " + arrayOfObjects[i].lastName;
		result[i].age = arrayOfObjects[i].age;
		result[i].gender = arrayOfObjects[i].gender;
	}
	return result;
}

var users = [{firstName: "Vasya", lastName: "Pupkin", age: 23, gender: "male"},
			{firstName: "Kolya", lastName: "Shmupkin", age: 53, gender: "male"},
			{firstName: "Petya", lastName: "Bubkin", age: 93, gender: "male"
			}];
console.log(namesConcatenator(users));
console.log(users);
*/
// LECTURE_09 - list_7_exersize_2
/* function getBorderNumbers (arrayOfNumbers, takeFrom) {
	if (takeFrom === "first") {
		return arrayOfNumbers.reduce (arrayBuilder, []);
	}
	if (takeFrom === "last") {
		return arrayOfNumbers.reduceRight (arrayBuilder, []);
	}
	function arrayBuilder (array, elem) {
		if (elem > 0 && array.length < 3) {
			array.push(elem);
		}
	return array;
	}
}

console.log(getBorderNumbers([1, -2, -3, 4, 5, -6, -7, 8, -9], "last"));
console.log(getBorderNumbers([1, -2, -3, 4, 5, -6, -7, 8, -9], "first"));
*/
// LECTURE_09 - list_7_exersize_3
/* function getTotalPrice (arrayOfProducts) {
	var sum = 0;
	return arrayOfProducts.reduce (function (sum, element) {
		return (element.inCart) ? sum + parseFloat (element.price) : sum
	}, sum);
}
console.log(getTotalPrice([{name: "samsung", price: "100$", inCart: "true"},
							{name: "nokia", price: "50$", inCart: "true"},
							{name: "apple", price: "650$", inCart: "true"}
							]));
*/
// LECTURE_09 - list_8_exersize_1
/* function getSortedArray (arrayOfObjects, sortBy, order) {
	if (!arrayOfObjects.length) {
		return arrayOfObjects;
	}
	var compare;
	if (typeof arrayOfObjects[0][sortBy] === "number") {
		compare = function (a, b) { return a[sortBy] - b[sortBy] };
	}
	else if (typeof arrayOfObjects[0][sortBy] === "string" ) {
		compare = function (a, b) { return a[sortBy].toLowerCase() > b[sortBy].toLowerCase()};
	}
	
	return order === "descending" ? arrayOfObjects.sort (compare).reverse() : arrayOfObjects.sort (compare);
}

var users = [{name: "Vasiliy", age: 7, country: "Moldova"},
			{name: "Nikolay", age: 17, country: "Poland"},
			{name: "John", age: 37, country: "Canada"}
			];
console.log(getSortedArray(users, "name", "ascending"));
*/
// LECTURE_09 - list_8_exersize_2 (найти ошибку синтаксиса)
/* function greetingMatureUsers(arrayOfObjects) {
	var adultArray = arrayOfObjects.filter(function (element) {
		return element.age > 18 });
	
	adultArray.forEach(function(element) {
		Object.defineProperty(element, "greeting", {
			get: function () {
				return "Welcome " + (this.gender === "male" ? "mister" : "miss ") + this.name
			}
		})
		element.greeting = function () {
			
		};
	});
	return AdultArray;
}

var test = greetingMatureUsers ([{"name": "Helen", "age": "25", "gender": "female"},
	{"name": "Madlen", "age": "10", "gender": "female"},
	{"name": "Oleg", "age": "30", "gender": "male"},
	{"name": "Franc", "age": "18", "gender": "male"},
	{"name": "Lucas", "age": "9", "gender": "male"},
	{"name": "Mike", "age": "38", "gender": "male"}
	]);
	
test[0].gender = "mail";
console.log(test[0].greeting);
*/


/* LECTURE_10 (09.pptx) - даты */
// **********************************

/* Создание даты
в JS осуществляется с помощью конструктора Date.

var currentDate = new Date();
console.log(currentDate);

При объявлении без параметров, currentDate принимает текущий момент времени.

Дата в числовом значении - это количество милисекунд, прошедших с 1 января 1970 года. Зададим дату в милисекундах.

console.log(new Date(1000)); // Thu Jan 01 1970 02:00:01 GMT+0200 (FLE Standard Time)
*/
/* Конструктор
принимает в себя разные аргументы, если это одно число, то конструктор создаёт дату с new Date(milliseconds) или 1.1.1970 00:00:00:000 + переданное количество миллисекунд. 
new Date(1000) // 1.1.1970 00:00:01:000
Если это набор чисел то дата создаётся так
new Date(year, month, date, hours, minutes, seconds, milliseconds).


console.log(new Date (2000, 0, 1, 0, 0, 0, 0)); // Sat Jan 01 2000 00:00:00 GMT+0200 (FLE Standard Time)

 или можно отбросить часы, минуты, секунды и миллисекунды, получим то же самое
 
console.log(new Date (2000, 0, 1));  // Sat Jan 01 2000 00:00:00 GMT+0200 (FLE Standard Time), т. к. часы, минуты, секунды и миллисекунды по умолчанию 0.

Обратите внимание что месяцы начинаются с 0.
*/
/* Можно передавать дату одной строкой:
	YYYY-MM-DDTHH:mm:ss.sss+Z, где
YYYY-MM-DD – дата в формате год-месяц-день, T - разделитель

console.log(new Date("2000-01-01T00:00:01.500+02:00")); // Sat Jan 01 2000 00:00:01 GMT+0200 (FLE Standard Time)
Обычный символ T используется как разделитель.
HH:mm:ss.sss – время: часы-минуты-секунды-миллисекунды.
Часть 'Z' обозначает временную зону – в формате +-hh:mm, либо символ Z, обозначающий UTC. По стандарту её можно не указывать, тогда UTC, но в Safari с этим ошибка, так что лучше указывать всегда.
Также возможны укороченные варианты, например YYYY-MM-DD или YYYY-MM или даже только YYYY.
*/
/* Примеры
console.log(new Date("2000-02-01T20:20:20.200+02:00")); // Tue Feb 01 2000 20:20:20 GMT+0200

console.log(new Date("2000-02-01T20:20:20.200z")); // Tue Feb 01 2000 22:20:20 GMT+0200

запись тоже можно сокращать
console.log(new Date("2000")); // Sat Jan 01 2000 02:00:00 GMT+0200

У конструктора Date также есть метод parse, который принимает в себя строку и возвращает количество миллисекунд прошедших с 1.1.1970го.

console.log(Date.parse("2000-02-01T20:20:20.200z")); // 949436420200, это называется "time stamp"

Обратите внимание, что месяцы при создании даты из строки начинаются с 1.

Если параметры создания даты не корректны, то получим строку Invalid date. 
*/
/* Методы у даты
У объекта date есть набор методов для получения и изменения каких-то частей параметров.
Мы можем:
получить год(из 4 цифр)
getFullYear()

получить месяц, от 0 до 11.
getMonth()

получить число месяца, от 1 до 31.
getDate()

Получить соответствующие компоненты.
getHours();
getMinutes();
getSeconds();
getMilliseconds();

Также есть метод getYear, но он не описан в стандарте и работает в разных браузерах по разному, поэтому использовать его не рекомендуется.
*/
/* геттеры
var currentDate = new Date();

console.log(currentDate.getFullYear()); // 2017
console.log(currentDate.getMonth()); // 1 (февраль, месяцы начинаются с нуля)
console.log(currentDate.getDate()); // 7
console.log(currentDate.getHours()); // 3
console.log(currentDate.getMinutes()); // 17
console.log(currentDate.getSeconds()); // 54
console.log(currentDate.getMilliseconds()); // 119
(Все параметры возвращаются как "number")

getDay()
// Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).

getTime()
// Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, то есть того же вида, который используется в конструкторе new Date(milliseconds). Это почти то же самое, что и
Date.parse
// только Date.parse создаёт дату, а getTime получает

getTimezoneOffset()
// Возвращает разницу между местным и UTC-временем, в минутах.

console.log(currentDate.getDay()); // 2
console.log(currentDate.getTime()); // 1486431253477 (time stamp)
console.log(currentDate.getTimezoneOffset()); // -120 (в минутах)

// Когда мы создаём дату, она сразу создаётся со смещением по часовому поясу. У всех методов кроме getTime и getTimezoneOffset есть UTC варианты, которые возвращают части даты без смещения по часовому поясу:

console.log(new Date()); // Tue Feb 07 2017 03:45:37 GMT+0200 (FLE Standard Time)
console.log(new Date().getHours()); // 3 (локальное времч)
console.log(new Date().getUTCHours()); // 1 (время по Гринвичу)
*/
/* сеттеры
функции, обратные геттерам, можно (как показано ниже) пропускать необязательные параметры, но надо помнить, что годы, месяцы, дни не переходят в часы. С их помощью мы можем менять какие-то части даты, добавить сколько-то минут или убавить, и т.д. Все методы имеют UTC-вариант.

setFullYear(year [, month, date])
setMonth(month [, date])
setDate(date)
// ниже пошли часы
setHours(hour [, min, sec, ms])
setMinutes(min [, sec, ms])
setSeconds(sec [, ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)


var date = new Date(2000, 0, 0);
console.log(date.getFullYear()); // 1999
date = new Date(2000, 0, 1);
console.log(date.getFullYear()); // 2000
date.setFullYear(2001);
console.log(date); // Mon Jan 01 2001 00:00:00 GMT+0200 (FLE Standard Time)
date.setMonth(2);
console.log(date); // Thu Mar 01 2001 00:00:00 GMT+0200 (FLE Standard Time)
date.setHours(10);
console.log(date); // Thu Mar 01 2001 10:00:00 GMT+0200 (FLE Standard Time)
date.setMinutes(15);
console.log(date); // Thu Mar 01 2001 10:15:00 GMT+0200 (FLE Standard Time)
date.setSeconds(30);
console.log(date); // Thu Mar 01 2001 10:15:30 GMT+0200 (FLE Standard Time)

console.log(date.getMilliseconds()); // 0
date.setMilliseconds(350);
console.log(date.getMilliseconds()); // 350

// У всех методов кроме setTime также есть UTC варианты, которые устанавливают части даты без смещения по часовому поясу.
*/
/* Автоисправление даты
Объекты даты умеют корректировать ошибки в указании даты, к примеру, если указать дату больше чем последнее число текущего месяца, то лишние дни перенесутся на будущие месяцы, к примеру:

var date = new Date(2000, 0, 1); // 2000-01-01
date.setDate(35) // 2000-02-04

Если же указать нулевую дату, то объект дата установится последним днём предыдущего месяца, а если отрицательную, то JavaScript станет вычитать -n дней с конца предыдущего месяца. Нулевую дату можно использовать для выяснения количества дней в месяце, для определения високосного года.

пример:

var date = new Date (2000, 0, 0);
date.setDate(5);
console.log(date); // Sun Dec 05 1999 00:00:00 GMT+0200 (FLE Standard Time)
date.setDate(35);
console.log(date); // Tue Jan 04 2000 00:00:00 GMT+0200 (FLE Standard Time)
// допустим, мы хотим выяснить, каким было число предыдущего месяца:
date.setDate(0);
console.log(date); // Fri Dec 31 1999 00:00:00 GMT+0200 (FLE Standard Time)
// узнаем, каким был предпоследний день предыдущего месяца:
date.setDate(-1);
console.log(date.getDay()); // 1 (понедельник)
*/
/* Операции с датами
Даты можно сравнивать и вычитать, даты приводятся к time stamp-ам и сравниваются, как обычные числа, т.е., при вычитании дат вернётся их разница в миллисекундах.

сравнение и вычитание:
var date1 = new Date (2000, 0, 0);
var date2 = new Date (2000, 0, 0, 0, 0, 0, 500);

var date1 = new Date(2000, 0, 0);
var date2 = new Date(2000, 0, 0, 0, 0, 0, 500);

console.log(date1 > date2); // false
console.log(date2 - date1); // 500

хотим узнать, что какие-то события произошли в один день:

var startOfDay = new Date (2000, 0, 01, 0, 0, 0, 0);
var endOfDay = new Date (2000, 0, 01, 23, 59, 59, 999);
var anyDate = new Date(2000, 0, 01, 08, 54, 18, 345);
var anotherDate = new Date(2000, 0, 01, 19, 23, 08, 101);
console.log(startOfDay); // Sat Jan 01 2000 00:00:00 GMT+0200 (FLE Standard Time)
console.log(endOfDay); // Sat Jan 01 2000 23:59:59 GMT+0200 (FLE Standard Time)
console.log(anyDate); // Sat Jan 01 2000 08:54:18 GMT+0200 (FLE Standard Time)
console.log(anotherDate); // Sat Jan 01 2000 19:23:08 GMT+0200 (FLE Standard Time)

if((startOfDay <= anyDate && anyDate <= endOfDay) && (startOfDay <= anyDate && anotherDate <= endOfDay)) {
	console.log("It's the same day.");
}
*/
/* милисекунды в консоли не меняются
var time = {
  year: 2345,
  month: 11,
  day: 10,
  hour: 11,
  minute: 12,
  second: 13,
  microsecond: 123456
}

console.log(time); // (*)
time.microsecond++; // (**)

console.log(time);
time.microsecond++;

console.log(time);
time.microsecond++;

// милисекунды в консоли не меняются, потому что при «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения. Вывод не делает «копию» текущего содержимого, а сохраняет лишь ссылку на объект. Чтобы не ошибаться, надо делать вывод на уровне примитивов.
*/

/* LECTURE_10 (10.pptx) - контекст (слайды), не пройдена */
// **********************************

/* Контекст вызова функции
Любая функция в JS вызывается в контексте чего-либо. Контекст вызова функции доступен в функции с помощью ключевого слова this.
Контекст функции определяется не в момент объявления функции, а в момент её вызова, поэтому у одной и той же функции, в разных условиях, могут быть разные контексты, в зависимости от того кем и как эта функция вызвана.
В большинстве случаев контекстом функции является объект window или undefined, если включён режим "use strict".
Если функция вызывается! как метод объекта, то её контекстом является объект, чьим методом она является.
*/
/* , call, apply
Мы также можем подменить контекст вызова функции, для этого у функции в JS есть 3 метода, call, apply, bind.
Методы call и apply очень похожи и подменяют контекст вызова функции каждый раз когда вызывают её, разница между ними в том что в call аргументы передаются по отдельности, а в apply массивом, например.
var obj = {};
function fn(arg1, arg2) {}; // this === window
fn.call(obj, "arg1", "arg2"); // this === obj
fn.apply(obj, ["arg1", "arg2"]); // this === obj
*/
/* bind
Метод bind создаёт новый экземпляр функции, с привязанным к ней контекстом.
var obj = {};
function fn() {}; // this === window
var newFn = fn.bind(obj);
newFn(); // this === obj;
Связывание с использованием метода bind называет раннее связывание и у него есть 1 недостаток, если исходная функция изменится, то он будет продолжать вызывать старый экземпляр функции.
var obj = {
	   method: function () { console.log("oldMethod") }
	}
	var newFn = obj.method.bind(obj);
	newFn() // oldMethod;
	obj.method = function () { console.log("newMethod") }
	newFn() // oldMethod;
	*/
/* bindLate
Чтобы исправить ситуацию используется техника под названием позднее связывание и выглядит она так.
function bindLate(context, funcName) {
	  return function() {
		    return context[funcName].apply(context, arguments);
		  };
		}
		var obj = {
			   method: function () { console.log("oldMethod") }
			}
			var newFn = bindLate(obj, "method");
			newFn() // oldMethod;
			obj.method = function () { console.log("newMethod") }
			newFn() // newMethod;
*/
/* EventListener
Есть ещё один неявный контекст вызова функции, если мы создаём слушатель событий в браузере, то вызываемая им функция будет выполняться в контексте элемента на котором сработал слушатель.
document.querySelector("body").addEventListener("click", function () { console.log(this) }) // body element
О слушателях событий и о других функциях JS в браузере мы поговорим позднее.
*/
/* Цепные функции
Работая с JS вы довольно часто будете сталкиваться с цепными функциями, они очень часто используются в jQuery и нередко встречаются в других фреймворках.
Цепные функции это возможность вызывать функции одна за другой, например 
obj.method1(param).method2(param, param2).method1();
Принцип работы таких функций довольно прост, каждая функция в цепочке должно возвращать объект из которого мы можем вызвать следующую функцию, пример выше можно реализовать следующим образом
var obj = {
	   method1: function (param) {
		// code
		return this;},
	  method2: function (param,param2) {
		// code
		 return this;}
*/
/* Функции с коллбэком
Вам часто нужно будет организовать последовательный вызов нескольких функций, одна из которых должна быть переменной и делается это с помощь коллбэков.
function fn1(callback) {
	// code
	callback(); }
	function fn2() {};
	fn1(fn2);
*/
/* Замыкания
По окончании работы функции её переменные удаляются из памяти, но есть одна методика позволяющая сохранить эти переменные и продолжать с ними работать, это замыкания.
Замыкания создаются в том случае, когда на переменную ссылается какая-то функция, которая может быть вызвана позднее, например функция с отложенным вызовом или  слушатель событий. Но также можно создать замыкание использую только инструменты языка.
Пример 1. С задержкой.
function timeout() {
	   var x = 0;
	   console.log(x);
	   setTimeout(function () { x++; console.log(x); }, 1000);
	}
	timeout(); // console.log(0); console.log(1);
*/
/* Замыкания. Пример c слушателем.
function listener() {
	   var x = 0;   console.log(x);
	  document.querySelector("body").addEventListener(function () {
		    x++; 
		   console.log(x);
		});
		listener(); // 0 и +1 с каждым кликом;
*/
/* Замыкания инструментами языка.
Пример 3. Инструментами языка.
function JSClosure() {
	   var x = 0;
	   console.log(x); 
	return function () {
		    x++; 
		   console.log(x);
		};
		var closureFunction = JSClosure(); // 0
		closureFunction(); // 1;
		closureFunction(); // 2; 
		closureFunction(); // 3; 
*/
/* Модули
Модули используются, чтобы не хранить данные разных частей программы в общей области видимости, как правило реализация приблизительно такая.
(function () {
	   var myApplication = {};
	   myApplication.method1 = function () {};
	   myApplication.method2 = function () {}; 
	   myApplication.methodN = function () {};
	   myApplication.addModule = function (moduleName, module) {};
	   myApplication.getModule = function (moduleName) {};
	      window.myApplication = myApplication ;
	   })();
*/
/* инструмент для добавления новых методов или модулей
Что делать, если нужно добавить к myApplication что-то своё, скажем из скрипта в другом файле? Всё довольно просто, допустим мы захотели добавить методы для добавления и удаления класса, в базовом приложении должен быть инструмент для добавления новых методов или модулей.
(function () {
	  myApplication.addModule("classWorkers", {
		     addClass: function (element, class) {},
		     removeClass: function (element, class) {}
		  });
		})();
*/
/* функция для определения типа объекта
function getType(obj) {
	  return {}.toString.call(obj).slice(8, -1);
}
*/

/* LECTURE_11 - практика (модульное API) */
// **********************************
/* пишем модульное API
(function () {
	"use strict";
	var modules = {};
	var ourAwesomeApi = {};
	ourAwesomeApi.addModule = addModule;
	ourAwesomeApi.addMethod = addMethod;
	ourAwesomeApi.getModule = getModule;
	window.api = ourAwesomeApi;
	
	// Functions
	function addModule(name, module) {
		if (modules[name]) {
			throw("Module already exist");
		}
		else {
			var fn = new Function("return function " + name + "() {}")();
			fn.prototype = module;
			modules[name] = fn;
		}
	}
	
	function addMethod(moduleName, name, method) {
		if (!modules[moduleName]) {
			throw("Module does not exist");
		}
		else if (modules[moduleName].prototype[name]) {
			throw("Method already exist");
		}
		else {
			modules[moduleName].prototype[name] = method;
		}
	}
	
	function getModule(name) {
		if (modules[name]) {
				return new modules[name]();
			}
		else {
			throw("Modules does not exist");
		}
	};
})();
*/
/* тест
api.addModule("test", {});
api.addMethod("test", "testMethod", function () {console.log("Hooray!!!")});
var testModule = api.getModule("test");
console.log(testModule);
testModule.testMethod();
*/

// LECTURE_11 - практика, работа, RegExp API
// **********************************
/* hasTextBySample
function hasTextBySample(string, regExp) {
	return regExp.test(string);
};
console.log(hasTextBySample("test", /testo/));
*/
/* getMatches
function getMatches(string, regExp) {
	var regExpString = regExp.toString();
	var regExp = regExpString.slice(1, regExpString.lastIndexOf("/"));
	var flags = regExpString.slice(regExpString.lastIndexOf("/") + 1);
	if(~flags.indexOf("g")) {
		return string.match(regExp);
	}
	else {
		flags += "g";
		regExp = new RegExp(regExp, flags);
		return string.match(regExp);
	}
};
console.log(getMatches("stringst", /st/));
*/
/* getPartedPhone
function getPartedPhone(string) {
	var regExp = /\+(\d{1,2})[^](\d{3})[^](\d{3}-\d{2}-\d{2})/;
	if (regExp.test(string)) {
		var match = string.match(regExp);
		return {
			countryCode: match[1],
			cityCode: match[2],
			phone: match[3]
		}
	}
	else {
		throw("Invalid phone");
	}
};
console.log("+38(050)123-45-67");
*/
/* checkEveryLineMatch
function checkEveryLineMatch(string, regExp) {
	var lines = string.split(/\n/);
	return lines.every(function (line) {return regExp.test(line); });
}
console.log(checkEveryLineMatch("test\ntest\na\\n||", /\w+/m));
*/

/* LECTURE_12 - ООП в JS */
// **********************************

/* LECTURE_13 - JQUERY */
// **********************************

// примеры в main.js


/* LECTURE_14 - JQUERY */
// **********************************

// Document Object Model, DOM - это представление документа в виде дерева тегов. Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, каждый из которых образует отдельный узел. DOM — это инструмент, с помощью которого JavaScript видит содержимое HTML-страницы и состояние браузера. Самый внешний тег - <html>, поэтому дерево начинает расти от него. Внутри <html> находятся два узла: <head> и <body> - они становятся дочерними узлами для <html>. Каждый DOM-элемент является объектом и предоставляет свойства для манипуляции своим содержимым, для доступа к родителям и потомкам. У DOM-элементов есть масса свойств. Обычно используется максимум треть из них. Некоторые из них можно читать и устанавливать, другие - только читать. Атрибут есть у элементов-тегов и содержит имя тега в верхнем регистре, только для чтения.

Веб-страница - это документ. Этот документ может отображаться либо в окне браузера, либо как код HTML. Но в обоих случаях это один и тот же документ. Объектная модель документа (DOM) предоставляет ещё один способ представления, хранения и обработки того же документа. DOM - это объектно-ориентированное представление веб-страницы, и его можно модифицировать с помощью языка сценариев, такого как JavaScript.

// jQuery манипуляции атрибутами

var dataElem = $("[data-test]");
// console.log(dataElem.data("test"));
// console.log(dataElem.data("test2"));
// dataElem.data("test", "new value");
// console.log(dataElem.data("test"));
// dataElem.data({
	// "test": "new value test",
	// "test2": "new value test 2"
// });
// console.log(dataElem.data("test"));
// console.log(dataElem.data("test2"));
// dataElem.data("test2", {isValid: true});
// console.log(dataElem.data("test2"));
// dataElem.removeData("test2");
// console.log(dataElem.data("test2"));

// dataElem.removeAttr("data-test");
// dataElem.removeAttr("data-test2");
// dataElem.removeData(["data-test", "data-test2"]);
// console.log(dataElem.data("test"));
// console.log(dataElem.data("test2"));


// jQuery манипуляция стилями

var logoImage = $(".logo");
// console.log(logoImage.css("width"));
// console.log(logoImage.css(["position", "height"]));
// logoImage.css({
	// "position": "relative",
	// "height": "200px"
// });
// console.log(logoImage.css(["position", "height"]));
// logoImage.css("width", "200px");
// console.log(logoImage.css("width"));
// // console.log(window.getComputedStyle(logoImage[0]));
// console.log($(":radio:eq(0)")[0].value);
// console.log($(":radio:eq(2)")[0].value);
// console.log($(":radio:eq(2)").val());
// // $(":radio:eq(2)")[0].value === $(":radio:eq(2)").val()


// console.log(logoImage.height());
// logoImage.height(200);
// console.log(logoImage.height());

// console.log(logoImage.width());
// logoImage.width(200);
// console.log(logoImage.width());

// logoImage.width("10rem");
// console.log(logoImage.css("width"));
// console.log(logoImage.width());

// console.log(logoImage.innerWidth());
// logoImage.innerWidth(200);
// console.log(logoImage.width());
// console.log(logoImage.innerWidth());

// console.log(logoImage.outerWidth());
// console.log(logoImage.outerWidth(true));
// logoImage.outerWidth(200);
// console.log(logoImage.outerWidth());
// logoImage.outerWidth(200, true);
// console.log(logoImage.outerWidth());


// jQuery позиционирование элементов

// console.log(logoImage.offset());
// console.log(logoImage.position());
// logoImage.offset({"left": 0, "top": 50});
// console.log(logoImage.offset());

// // console.log(logoImage.position()); // нет setter'а

// var body = $("body");

// console.log(body.scrollLeft());
// console.log(body.scrollTop());
// setTimeout(function () {
	// body.scrollTop(20);
	// console.log(body.scrollLeft(50));
// }, 1000);


// jQuery events события

// logoImage.on("click", function () {
	// console.log("handler 1");
// }).on("click", function () {
	// console.log("handler 2");
// }).on("click", function () {
	// console.log("handler 3");
// }); // click at picture


// logoImage.parent().on("click", function () {
	// console.log("Bubbled event");
// });
// logoImage.on("click", function (e) {
	// console.log("handler 1");
// }).on("click", function () {
	// console.log("handler 2");
// }).on("click", function () {
	// console.log("handler 3");
// }); // click at picture

// logoImage.parent().on("click", function () {
	// console.log("Bubbled event");
// });
// logoImage.on("click", function (e) {
	// console.log("handler 1");
	// e.stopPropagation();
// }).on("click", function () {
	// console.log("handler 2");
// }).on("click", function () {
	// console.log("handler 3");
// }); // click at picture

// logoImage.parent().on("click", function () {
	// console.log("Bubbled event");
// });
// logoImage.on("click", function (e) {
	// console.log("handler 1");
	// e.stopImmediatePropagation();
// }).on("click", function () {
	// console.log("handler 2");
// }).on("click", function () {
	// console.log("handler 3");
// }); // click at picture

// logoImage.parent().on("click", function () {
	// console.log("Bubbled event");
// });
// logoImage.on("click", function (e) {
	// console.log("handler 1");
	// e.stopImmediatePropagation();
// }).on("click", function () {
	// console.log("handler 2");
// }).on("click", function () {
	// console.log("handler 3");
// }); // click at picture

// $(":text").on("keydown", function (e) {
	// if (e.keyCode === 13) {
		// alert('enter!');
	// }
// });

// logoImage.parent().on("click", function () {
	// console.log("Bubbled event");
// });
// logoImage.on("click", function (e) {
	// console.log("handler 1");
	// e.stopImmediatePropagation();
// }).on("click", function () {
	// console.log("handler 2");
// }).on("click", function () {
	// console.log("handler 3");
// }); // click at picture

// $(":text").on("keydown", function (e) {
	// if (e.keyCode === 13) {
		// alert('enter!');
		// e.preventDefault();   
	// }
// });

// $("a").on("click", function (e) {
	// console.log(e);
	// e.preventDefault();
// });

// logoImage.parent().on("click", function () {
	// console.log("Bubbled event");
// });
// $("a").on("click", false);

// logoImage.parent().on("click", function () {
	// console.log("Bubbled event");
// });
// $("a").on("click", false).on("click", function () {
	// console.log("asd");
// } );



/* LECTURE_16 - JQUERY */
// **********************************
// $(window).on("resize", function (e) {
	// console.log(e, window.innerWidth);
// } )

// $(window).on("scroll", function (e) {
	// console.log($(window).scrollTop());
// })

// $(document).ready(function () {}); // not recommended
// $(document).on("ready", function () {}); // not recommended
// $(function () {
	// $("h1").hide();
// })

// // код клавиш клавиатуры 
// $(document).on("keydown", function (e){
	// console.log(e.keyCode);
// })

// // keyup, код клавиш клавиатуры срабатывает на отжатие всегда один раз
// $(":text:eq(0)").on("keyup", function (e) {
	// console.log("input " + e.keyCode);
// })

// // отслеживаем клик мышкой. При клике мышкой на кнопку submit, submit отправляет данные и перезагружает страницу, поэтому консоль очищается
// $("button").on("click", function (e){
	// console.log(e.clientX, e.clientY);
// })
// // чтобы консоль не очищалась, в консоли можно зачекать Preserve log чекбокс
// $("button").on("click", function (e){
	// e.preventDefault();
	// console.log(e.clientX, e.clientY);
// })
// // e.preventDefault() метод event'а, он отменяет стандартное поведение, поэтому submit ничего не отправляет, консоль не перезагружается

// // отслеживаем контекстное меню, вызванное на элементе
// $("img").on("contextmenu", function (e){
	// e.preventDefault();
	// console.log(e.clientX, e.clientY);
// })

// // событие, которое срабатывает при двойном клике на элемент
// $("h1, img").on("dblclick", function (e){
	// console.log(e.target);
// });
// //на "img" dblclick срабатывает дважды, потому что мы повесили обработчик событий на два элемента - img и h1, но когда событие отлавливается и на родительском элементе h1, то в консоли всё равно пишет событие на img - контекст, сцуко, сохраняется

// // кликом считается mousedown и mouseup были на одном и том же элементе, если mousedown произойдёт на одном элементе, а mouseup на другом, клик не отловится

// $("button").on("mousedown", null, "It's mousedown event",
// function (e) {
	// console.log(e.data);
// }).on("mousemove", null, "It's mousemove event", function (e) {
	// console.log(e.data);
// }).on("mouseup", null, "It's mouseup event", function (e) {
	// console.log(e.data);
// })
// срабатывает на обеих клавишах мыши

// при зажати кнопки мыши, консоль видит
// It's mousedown event
// It's mousemove event

// при отпускани кнопки мыши, консоль видит
// It's mousedown event
// It's mousemove event

// при перемещении курсора (как с зажатой, так и с отпущенной кнопкой мыши) над кнопкой, консоль видит
// It's mousemove event

// В $() второй и третий параметры не обязательны, второй параметр - селектор, третий - передаваемые данные. Без null, jQuery() принимает строку "It's mousedown event" за селектор, а не за передаваемые данные и не работает.

// $("button").on("mousedown", null, "It's mousedown event",
// function (e) {
	// console.log(e.data);
// }).on("mousemove", null, "It's mousemove event", function (e) {
	// console.log(e.data);
// }).on("mouseup", null, "It's mouseup event", function (e) {
	// console.log(e.data);
// }).on("click", false);

// .on("click", false) - кнопка теперь не пытается сабмитить элементы, что видно по адресной строке, в которой не появляется ...?email=&phone=

// focus == focusin, focusout == blur - теги придуманы в разное время и оставлены все варианты для совместимости, чаще используют focus и blur, как самые короткие. Событие focus срабатывает, когда элемент получает фокус, событие blur срабатывает, когда элемент теряет фокус.

// $("input").on("focus", function (e){
	// console.log("focus", e.target);
// }).on("blur",  function (e){
	// console.log("blur", e.target);
// })
 // в index.html заменили строку
// <button type="submit">Submit</button>
// на строку
// <input type="button" value="Submit" />,
// потому что не срабатывал focus на кнопке, когда она была button,
// но стал срабатывать, когда кнопка стала input

// $("input").on("change", function (e){
	// console.log(e.target.value); // получаем атрибут value без использования обёртки jQuery, этот способ работает во всех браузерах
// })
// событие change срабатывает на радиокнопках, чекбоксах, а так же при потере фокуса в форме ввода текста:

// $("input").on("change", function (e){
	// console.log(e.target.value);
// }).on("select", function () {
	// console.log("selected")
// });

// если мы хотим вернуть выделенный фрагмент, изменим код:

// $("input").on("change", function (e){
	// console.log(e.target.value);
// }).on("select", function (e) {
	// console.log(e.target.value.slice(
		// e.target.selectionStart,
		// e.target.selectionEnd
	// ));
// });

// запрещаем пользователю ПОЧТИ любые действия мышкой, радиокнопки и чекбоксы помечаются и, как минимум, on("change") срабатывает
// $(document).on("mousedown", false);

// для запрета копирования можно поэкспериментировать с запретом горячих клавиш, контекстного меню и консоли (для windows desktop должно сработать, если только не переопределялись горячие клавиши)
// а вообще, нужно поискать событие, при котором информация попадает в буфер, и отменить это событие - так сработает без вопросов:

// $(window).on("contextmenu", false); // запретили контекстное меню для правой кнопки мыши
// $(window).on("keydown", null, "17", false); // клавиша ctrl - код 17 - запрещаем выделение через ctrl + a
// $(window).on("keydown", null, "123", false); // клавиша F12 - код 123 - запрет копирования через консоль

// submit - событие, которое срабатывает при отправке формы:
// в index.html меняем(снова возвращаем) строку
// <input type="button" value="Submit" />
// на строку
// <input type="submit" value="Submit" />


// Если мы не хотим сабмитить форму, но просто провалидировать форму (если форма не прошла валидацию, прерываем событие - делаем preventDefault, форма не отправляется, иначе - оставляем как есть, событие не прервано) или же мы хотим засабмитить её AJAX-ом, (тогда надо "руками" собрать данные из формы и отправить их в AJAX) то необходимо отменить стандартное поведение submit:
// $("form").on("submit", function (e){
	// e.preventDefault();
	// console.log("submit");
// })
// инпуты плохо стилизуются, поэтому, для AJAX и не только, применять именно form submit не принципиально, главное - собрать данные для отправки // возможно, неточно передана мысль

// прервано на 01:09:30























*************************************

/*
Объявление регулярного выражения. */
var regExp = /abc/g;
var regExp = new RegExp("abc", "g");
/*
В строках есть 3 основных метода позволяющие использовать регулярные выражения для работы со строками, match, search и replace.
В регулярных выражениях тоже есть методы для поиска в строке, это test и exec.
Метод search позволяет находить совпадение в строке, так же как и метод indexOf и так же возвращает индекс начала совпадения, только работает с регулярными выражениями.
Метод match также позволяет находить совпадение в строке, но возвращает другой набор параметров: 
- Если совпадение не найдено, он возвращает null. 
- Если совпадение найдено, то он возвращает массив, первым элементом которого будет полная строка совпадения, остальными частичные совпадения(совпадения с теми частями что идут в скобках, в регулярном выражении), а также 2 дополнительных атрибута, index, индекс совпадения и input, исходная строка. 
Метод replace позволяет не только найти что-то в тексте, но и заменить его на переданную ему строку или с помощью функции. Метод принимает 2 параметра, первый - регулярное выражение, второй -  строка на которую будут заменены совпадения или функция которая будет принимать в себя совпадения и производить замену.
Методы регулярного выражения test и exec аналогичны методам строки search и match с той лишь разницей что метод test возвращает не индекс совпадения, а true или false, в зависимости от того найдено что-то или нет.
*/
/* Регулярные выражения Basics
a - символ a
ab - строка ab
a|b - a или b
a* - 0 или больше a
\ - экранирование
*/
/* Quantifiers
* - 0 или более
+ - 1 или более
? - 0 или 1
{2} - 2 ровно
{2, 5} - между 2 и 5
{2,} - 2 или более
*/
/* Character Classes
[ab-d] - один из a,b,c,d
[^ab-d] - один, за исключением a,b,c,d
[\b] - символ Backspace
\d - одна цифра
\D - одна не цифра
\s - один пробел
\S - один не пробел
\w - один символ слова?
\W - один несимвол слова,
*/
/* Assertions
^ - начало строки
$ - конец строки
\b - граница слова
\B - не граница слова
(?=...) - Positive lookahead
(?!...) - Negative lookahead
*/
/* Groups
(...) - захват группы?
(?...) - незахваченная группа?
\Y - совпадение ??
*/
/* Flags
g - global
i - ignore
m - ^ и $ с начала строки
*/

















